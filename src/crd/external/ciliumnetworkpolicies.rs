// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium ciliumnetworkpolicies.cilium.io
// kopium version: 0.21.1

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
    pub use k8s_openapi::apimachinery::pkg::util::intstr::IntOrString;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

#[derive(CustomResource, Serialize, Deserialize, Clone, Debug)]
#[kube(group = "cilium.io", version = "v2", kind = "CiliumNetworkPolicy", plural = "ciliumnetworkpolicies")]
#[kube(namespaced)]
#[kube(status = "CiliumNetworkPolicyStatus")]
#[kube(schema = "disabled")]
pub struct CiliumNetworkPolicySpec {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub egress: Option<Vec<CiliumNetworkPolicyEgress>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "egressDeny")]
    pub egress_deny: Option<Vec<CiliumNetworkPolicyEgressDeny>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableDefaultDeny")]
    pub enable_default_deny: Option<CiliumNetworkPolicyEnableDefaultDeny>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endpointSelector")]
    pub endpoint_selector: Option<CiliumNetworkPolicyEndpointSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ingress: Option<Vec<CiliumNetworkPolicyIngress>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ingressDeny")]
    pub ingress_deny: Option<Vec<CiliumNetworkPolicyIngressDeny>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<Vec<CiliumNetworkPolicyLabels>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeSelector")]
    pub node_selector: Option<CiliumNetworkPolicyNodeSelector>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyEgress {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authentication: Option<CiliumNetworkPolicyEgressAuthentication>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub icmps: Option<Vec<CiliumNetworkPolicyEgressIcmps>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toCIDR")]
    pub to_cidr: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toCIDRSet")]
    pub to_cidr_set: Option<Vec<CiliumNetworkPolicyEgressToCidrSet>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toEndpoints")]
    pub to_endpoints: Option<Vec<CiliumNetworkPolicyEgressToEndpoints>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toEntities")]
    pub to_entities: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toFQDNs")]
    pub to_fqd_ns: Option<Vec<CiliumNetworkPolicyEgressToFqdNs>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toGroups")]
    pub to_groups: Option<Vec<CiliumNetworkPolicyEgressToGroups>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toNodes")]
    pub to_nodes: Option<Vec<CiliumNetworkPolicyEgressToNodes>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toPorts")]
    pub to_ports: Option<Vec<CiliumNetworkPolicyEgressToPorts>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toRequires")]
    pub to_requires: Option<Vec<CiliumNetworkPolicyEgressToRequires>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toServices")]
    pub to_services: Option<Vec<CiliumNetworkPolicyEgressToServices>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyEgressAuthentication {
    pub mode: CiliumNetworkPolicyEgressAuthenticationMode,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum CiliumNetworkPolicyEgressAuthenticationMode {
    #[serde(rename = "disabled")]
    Disabled,
    #[serde(rename = "required")]
    Required,
    #[serde(rename = "test-always-fail")]
    TestAlwaysFail,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyEgressIcmps {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fields: Option<Vec<CiliumNetworkPolicyEgressIcmpsFields>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyEgressIcmpsFields {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub family: Option<CiliumNetworkPolicyEgressIcmpsFieldsFamily>,
    #[serde(rename = "type")]
    pub r#type: IntOrString,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum CiliumNetworkPolicyEgressIcmpsFieldsFamily {
    IPv4,
    IPv6,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyEgressToCidrSet {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cidr: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cidrGroupRef")]
    pub cidr_group_ref: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub except: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyEgressToEndpoints {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CiliumNetworkPolicyEgressToEndpointsMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyEgressToEndpointsMatchExpressions {
    pub key: String,
    pub operator: CiliumNetworkPolicyEgressToEndpointsMatchExpressionsOperator,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum CiliumNetworkPolicyEgressToEndpointsMatchExpressionsOperator {
    In,
    NotIn,
    Exists,
    DoesNotExist,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyEgressToFqdNs {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchName")]
    pub match_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchPattern")]
    pub match_pattern: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyEgressToGroups {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub aws: Option<CiliumNetworkPolicyEgressToGroupsAws>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyEgressToGroupsAws {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub region: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityGroupsIds")]
    pub security_groups_ids: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityGroupsNames")]
    pub security_groups_names: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyEgressToNodes {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CiliumNetworkPolicyEgressToNodesMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyEgressToNodesMatchExpressions {
    pub key: String,
    pub operator: CiliumNetworkPolicyEgressToNodesMatchExpressionsOperator,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum CiliumNetworkPolicyEgressToNodesMatchExpressionsOperator {
    In,
    NotIn,
    Exists,
    DoesNotExist,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyEgressToPorts {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub listener: Option<CiliumNetworkPolicyEgressToPortsListener>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "originatingTLS")]
    pub originating_tls: Option<CiliumNetworkPolicyEgressToPortsOriginatingTls>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ports: Option<Vec<CiliumNetworkPolicyEgressToPortsPorts>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rules: Option<CiliumNetworkPolicyEgressToPortsRules>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverNames")]
    pub server_names: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminatingTLS")]
    pub terminating_tls: Option<CiliumNetworkPolicyEgressToPortsTerminatingTls>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyEgressToPortsListener {
    #[serde(rename = "envoyConfig")]
    pub envoy_config: CiliumNetworkPolicyEgressToPortsListenerEnvoyConfig,
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub priority: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyEgressToPortsListenerEnvoyConfig {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kind: Option<CiliumNetworkPolicyEgressToPortsListenerEnvoyConfigKind>,
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum CiliumNetworkPolicyEgressToPortsListenerEnvoyConfigKind {
    CiliumEnvoyConfig,
    CiliumClusterwideEnvoyConfig,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyEgressToPortsOriginatingTls {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub certificate: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateKey")]
    pub private_key: Option<String>,
    pub secret: CiliumNetworkPolicyEgressToPortsOriginatingTlsSecret,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "trustedCA")]
    pub trusted_ca: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyEgressToPortsOriginatingTlsSecret {
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyEgressToPortsPorts {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endPort")]
    pub end_port: Option<i32>,
    pub port: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub protocol: Option<CiliumNetworkPolicyEgressToPortsPortsProtocol>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum CiliumNetworkPolicyEgressToPortsPortsProtocol {
    #[serde(rename = "TCP")]
    Tcp,
    #[serde(rename = "UDP")]
    Udp,
    #[serde(rename = "SCTP")]
    Sctp,
    #[serde(rename = "ANY")]
    Any,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyEgressToPortsRules {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dns: Option<Vec<CiliumNetworkPolicyEgressToPortsRulesDns>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub http: Option<Vec<CiliumNetworkPolicyEgressToPortsRulesHttp>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kafka: Option<Vec<CiliumNetworkPolicyEgressToPortsRulesKafka>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub l7: Option<Vec<BTreeMap<String, String>>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub l7proto: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyEgressToPortsRulesDns {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchName")]
    pub match_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchPattern")]
    pub match_pattern: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyEgressToPortsRulesHttp {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerMatches")]
    pub header_matches: Option<Vec<CiliumNetworkPolicyEgressToPortsRulesHttpHeaderMatches>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyEgressToPortsRulesHttpHeaderMatches {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mismatch: Option<CiliumNetworkPolicyEgressToPortsRulesHttpHeaderMatchesMismatch>,
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<CiliumNetworkPolicyEgressToPortsRulesHttpHeaderMatchesSecret>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum CiliumNetworkPolicyEgressToPortsRulesHttpHeaderMatchesMismatch {
    #[serde(rename = "LOG")]
    Log,
    #[serde(rename = "ADD")]
    Add,
    #[serde(rename = "DELETE")]
    Delete,
    #[serde(rename = "REPLACE")]
    Replace,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyEgressToPortsRulesHttpHeaderMatchesSecret {
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyEgressToPortsRulesKafka {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiKey")]
    pub api_key: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientID")]
    pub client_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub role: Option<CiliumNetworkPolicyEgressToPortsRulesKafkaRole>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub topic: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum CiliumNetworkPolicyEgressToPortsRulesKafkaRole {
    #[serde(rename = "produce")]
    Produce,
    #[serde(rename = "consume")]
    Consume,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyEgressToPortsTerminatingTls {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub certificate: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateKey")]
    pub private_key: Option<String>,
    pub secret: CiliumNetworkPolicyEgressToPortsTerminatingTlsSecret,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "trustedCA")]
    pub trusted_ca: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyEgressToPortsTerminatingTlsSecret {
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyEgressToRequires {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CiliumNetworkPolicyEgressToRequiresMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyEgressToRequiresMatchExpressions {
    pub key: String,
    pub operator: CiliumNetworkPolicyEgressToRequiresMatchExpressionsOperator,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum CiliumNetworkPolicyEgressToRequiresMatchExpressionsOperator {
    In,
    NotIn,
    Exists,
    DoesNotExist,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyEgressToServices {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "k8sService")]
    pub k8s_service: Option<CiliumNetworkPolicyEgressToServicesK8sService>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "k8sServiceSelector")]
    pub k8s_service_selector: Option<CiliumNetworkPolicyEgressToServicesK8sServiceSelector>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyEgressToServicesK8sService {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceName")]
    pub service_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyEgressToServicesK8sServiceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    pub selector: CiliumNetworkPolicyEgressToServicesK8sServiceSelectorSelector,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyEgressToServicesK8sServiceSelectorSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CiliumNetworkPolicyEgressToServicesK8sServiceSelectorSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyEgressToServicesK8sServiceSelectorSelectorMatchExpressions {
    pub key: String,
    pub operator: CiliumNetworkPolicyEgressToServicesK8sServiceSelectorSelectorMatchExpressionsOperator,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum CiliumNetworkPolicyEgressToServicesK8sServiceSelectorSelectorMatchExpressionsOperator {
    In,
    NotIn,
    Exists,
    DoesNotExist,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyEgressDeny {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub icmps: Option<Vec<CiliumNetworkPolicyEgressDenyIcmps>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toCIDR")]
    pub to_cidr: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toCIDRSet")]
    pub to_cidr_set: Option<Vec<CiliumNetworkPolicyEgressDenyToCidrSet>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toEndpoints")]
    pub to_endpoints: Option<Vec<CiliumNetworkPolicyEgressDenyToEndpoints>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toEntities")]
    pub to_entities: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toGroups")]
    pub to_groups: Option<Vec<CiliumNetworkPolicyEgressDenyToGroups>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toNodes")]
    pub to_nodes: Option<Vec<CiliumNetworkPolicyEgressDenyToNodes>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toPorts")]
    pub to_ports: Option<Vec<CiliumNetworkPolicyEgressDenyToPorts>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toRequires")]
    pub to_requires: Option<Vec<CiliumNetworkPolicyEgressDenyToRequires>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toServices")]
    pub to_services: Option<Vec<CiliumNetworkPolicyEgressDenyToServices>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyEgressDenyIcmps {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fields: Option<Vec<CiliumNetworkPolicyEgressDenyIcmpsFields>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyEgressDenyIcmpsFields {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub family: Option<CiliumNetworkPolicyEgressDenyIcmpsFieldsFamily>,
    #[serde(rename = "type")]
    pub r#type: IntOrString,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum CiliumNetworkPolicyEgressDenyIcmpsFieldsFamily {
    IPv4,
    IPv6,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyEgressDenyToCidrSet {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cidr: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cidrGroupRef")]
    pub cidr_group_ref: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub except: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyEgressDenyToEndpoints {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CiliumNetworkPolicyEgressDenyToEndpointsMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyEgressDenyToEndpointsMatchExpressions {
    pub key: String,
    pub operator: CiliumNetworkPolicyEgressDenyToEndpointsMatchExpressionsOperator,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum CiliumNetworkPolicyEgressDenyToEndpointsMatchExpressionsOperator {
    In,
    NotIn,
    Exists,
    DoesNotExist,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyEgressDenyToGroups {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub aws: Option<CiliumNetworkPolicyEgressDenyToGroupsAws>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyEgressDenyToGroupsAws {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub region: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityGroupsIds")]
    pub security_groups_ids: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityGroupsNames")]
    pub security_groups_names: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyEgressDenyToNodes {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CiliumNetworkPolicyEgressDenyToNodesMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyEgressDenyToNodesMatchExpressions {
    pub key: String,
    pub operator: CiliumNetworkPolicyEgressDenyToNodesMatchExpressionsOperator,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum CiliumNetworkPolicyEgressDenyToNodesMatchExpressionsOperator {
    In,
    NotIn,
    Exists,
    DoesNotExist,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyEgressDenyToPorts {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ports: Option<Vec<CiliumNetworkPolicyEgressDenyToPortsPorts>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyEgressDenyToPortsPorts {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endPort")]
    pub end_port: Option<i32>,
    pub port: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub protocol: Option<CiliumNetworkPolicyEgressDenyToPortsPortsProtocol>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum CiliumNetworkPolicyEgressDenyToPortsPortsProtocol {
    #[serde(rename = "TCP")]
    Tcp,
    #[serde(rename = "UDP")]
    Udp,
    #[serde(rename = "SCTP")]
    Sctp,
    #[serde(rename = "ANY")]
    Any,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyEgressDenyToRequires {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CiliumNetworkPolicyEgressDenyToRequiresMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyEgressDenyToRequiresMatchExpressions {
    pub key: String,
    pub operator: CiliumNetworkPolicyEgressDenyToRequiresMatchExpressionsOperator,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum CiliumNetworkPolicyEgressDenyToRequiresMatchExpressionsOperator {
    In,
    NotIn,
    Exists,
    DoesNotExist,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyEgressDenyToServices {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "k8sService")]
    pub k8s_service: Option<CiliumNetworkPolicyEgressDenyToServicesK8sService>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "k8sServiceSelector")]
    pub k8s_service_selector: Option<CiliumNetworkPolicyEgressDenyToServicesK8sServiceSelector>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyEgressDenyToServicesK8sService {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceName")]
    pub service_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyEgressDenyToServicesK8sServiceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    pub selector: CiliumNetworkPolicyEgressDenyToServicesK8sServiceSelectorSelector,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyEgressDenyToServicesK8sServiceSelectorSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CiliumNetworkPolicyEgressDenyToServicesK8sServiceSelectorSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyEgressDenyToServicesK8sServiceSelectorSelectorMatchExpressions {
    pub key: String,
    pub operator: CiliumNetworkPolicyEgressDenyToServicesK8sServiceSelectorSelectorMatchExpressionsOperator,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum CiliumNetworkPolicyEgressDenyToServicesK8sServiceSelectorSelectorMatchExpressionsOperator {
    In,
    NotIn,
    Exists,
    DoesNotExist,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyEnableDefaultDeny {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub egress: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ingress: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyEndpointSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CiliumNetworkPolicyEndpointSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyEndpointSelectorMatchExpressions {
    pub key: String,
    pub operator: CiliumNetworkPolicyEndpointSelectorMatchExpressionsOperator,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum CiliumNetworkPolicyEndpointSelectorMatchExpressionsOperator {
    In,
    NotIn,
    Exists,
    DoesNotExist,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyIngress {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authentication: Option<CiliumNetworkPolicyIngressAuthentication>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fromCIDR")]
    pub from_cidr: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fromCIDRSet")]
    pub from_cidr_set: Option<Vec<CiliumNetworkPolicyIngressFromCidrSet>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fromEndpoints")]
    pub from_endpoints: Option<Vec<CiliumNetworkPolicyIngressFromEndpoints>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fromEntities")]
    pub from_entities: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fromGroups")]
    pub from_groups: Option<Vec<CiliumNetworkPolicyIngressFromGroups>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fromNodes")]
    pub from_nodes: Option<Vec<CiliumNetworkPolicyIngressFromNodes>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fromRequires")]
    pub from_requires: Option<Vec<CiliumNetworkPolicyIngressFromRequires>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub icmps: Option<Vec<CiliumNetworkPolicyIngressIcmps>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toPorts")]
    pub to_ports: Option<Vec<CiliumNetworkPolicyIngressToPorts>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyIngressAuthentication {
    pub mode: CiliumNetworkPolicyIngressAuthenticationMode,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum CiliumNetworkPolicyIngressAuthenticationMode {
    #[serde(rename = "disabled")]
    Disabled,
    #[serde(rename = "required")]
    Required,
    #[serde(rename = "test-always-fail")]
    TestAlwaysFail,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyIngressFromCidrSet {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cidr: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cidrGroupRef")]
    pub cidr_group_ref: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub except: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyIngressFromEndpoints {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CiliumNetworkPolicyIngressFromEndpointsMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyIngressFromEndpointsMatchExpressions {
    pub key: String,
    pub operator: CiliumNetworkPolicyIngressFromEndpointsMatchExpressionsOperator,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum CiliumNetworkPolicyIngressFromEndpointsMatchExpressionsOperator {
    In,
    NotIn,
    Exists,
    DoesNotExist,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyIngressFromGroups {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub aws: Option<CiliumNetworkPolicyIngressFromGroupsAws>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyIngressFromGroupsAws {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub region: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityGroupsIds")]
    pub security_groups_ids: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityGroupsNames")]
    pub security_groups_names: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyIngressFromNodes {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CiliumNetworkPolicyIngressFromNodesMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyIngressFromNodesMatchExpressions {
    pub key: String,
    pub operator: CiliumNetworkPolicyIngressFromNodesMatchExpressionsOperator,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum CiliumNetworkPolicyIngressFromNodesMatchExpressionsOperator {
    In,
    NotIn,
    Exists,
    DoesNotExist,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyIngressFromRequires {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CiliumNetworkPolicyIngressFromRequiresMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyIngressFromRequiresMatchExpressions {
    pub key: String,
    pub operator: CiliumNetworkPolicyIngressFromRequiresMatchExpressionsOperator,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum CiliumNetworkPolicyIngressFromRequiresMatchExpressionsOperator {
    In,
    NotIn,
    Exists,
    DoesNotExist,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyIngressIcmps {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fields: Option<Vec<CiliumNetworkPolicyIngressIcmpsFields>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyIngressIcmpsFields {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub family: Option<CiliumNetworkPolicyIngressIcmpsFieldsFamily>,
    #[serde(rename = "type")]
    pub r#type: IntOrString,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum CiliumNetworkPolicyIngressIcmpsFieldsFamily {
    IPv4,
    IPv6,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyIngressToPorts {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub listener: Option<CiliumNetworkPolicyIngressToPortsListener>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "originatingTLS")]
    pub originating_tls: Option<CiliumNetworkPolicyIngressToPortsOriginatingTls>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ports: Option<Vec<CiliumNetworkPolicyIngressToPortsPorts>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rules: Option<CiliumNetworkPolicyIngressToPortsRules>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverNames")]
    pub server_names: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminatingTLS")]
    pub terminating_tls: Option<CiliumNetworkPolicyIngressToPortsTerminatingTls>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyIngressToPortsListener {
    #[serde(rename = "envoyConfig")]
    pub envoy_config: CiliumNetworkPolicyIngressToPortsListenerEnvoyConfig,
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub priority: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyIngressToPortsListenerEnvoyConfig {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kind: Option<CiliumNetworkPolicyIngressToPortsListenerEnvoyConfigKind>,
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum CiliumNetworkPolicyIngressToPortsListenerEnvoyConfigKind {
    CiliumEnvoyConfig,
    CiliumClusterwideEnvoyConfig,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyIngressToPortsOriginatingTls {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub certificate: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateKey")]
    pub private_key: Option<String>,
    pub secret: CiliumNetworkPolicyIngressToPortsOriginatingTlsSecret,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "trustedCA")]
    pub trusted_ca: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyIngressToPortsOriginatingTlsSecret {
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyIngressToPortsPorts {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endPort")]
    pub end_port: Option<i32>,
    pub port: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub protocol: Option<CiliumNetworkPolicyIngressToPortsPortsProtocol>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum CiliumNetworkPolicyIngressToPortsPortsProtocol {
    #[serde(rename = "TCP")]
    Tcp,
    #[serde(rename = "UDP")]
    Udp,
    #[serde(rename = "SCTP")]
    Sctp,
    #[serde(rename = "ANY")]
    Any,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyIngressToPortsRules {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dns: Option<Vec<CiliumNetworkPolicyIngressToPortsRulesDns>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub http: Option<Vec<CiliumNetworkPolicyIngressToPortsRulesHttp>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kafka: Option<Vec<CiliumNetworkPolicyIngressToPortsRulesKafka>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub l7: Option<Vec<BTreeMap<String, String>>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub l7proto: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyIngressToPortsRulesDns {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchName")]
    pub match_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchPattern")]
    pub match_pattern: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyIngressToPortsRulesHttp {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerMatches")]
    pub header_matches: Option<Vec<CiliumNetworkPolicyIngressToPortsRulesHttpHeaderMatches>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyIngressToPortsRulesHttpHeaderMatches {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mismatch: Option<CiliumNetworkPolicyIngressToPortsRulesHttpHeaderMatchesMismatch>,
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<CiliumNetworkPolicyIngressToPortsRulesHttpHeaderMatchesSecret>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum CiliumNetworkPolicyIngressToPortsRulesHttpHeaderMatchesMismatch {
    #[serde(rename = "LOG")]
    Log,
    #[serde(rename = "ADD")]
    Add,
    #[serde(rename = "DELETE")]
    Delete,
    #[serde(rename = "REPLACE")]
    Replace,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyIngressToPortsRulesHttpHeaderMatchesSecret {
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyIngressToPortsRulesKafka {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiKey")]
    pub api_key: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientID")]
    pub client_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub role: Option<CiliumNetworkPolicyIngressToPortsRulesKafkaRole>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub topic: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum CiliumNetworkPolicyIngressToPortsRulesKafkaRole {
    #[serde(rename = "produce")]
    Produce,
    #[serde(rename = "consume")]
    Consume,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyIngressToPortsTerminatingTls {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub certificate: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateKey")]
    pub private_key: Option<String>,
    pub secret: CiliumNetworkPolicyIngressToPortsTerminatingTlsSecret,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "trustedCA")]
    pub trusted_ca: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyIngressToPortsTerminatingTlsSecret {
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyIngressDeny {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fromCIDR")]
    pub from_cidr: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fromCIDRSet")]
    pub from_cidr_set: Option<Vec<CiliumNetworkPolicyIngressDenyFromCidrSet>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fromEndpoints")]
    pub from_endpoints: Option<Vec<CiliumNetworkPolicyIngressDenyFromEndpoints>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fromEntities")]
    pub from_entities: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fromGroups")]
    pub from_groups: Option<Vec<CiliumNetworkPolicyIngressDenyFromGroups>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fromNodes")]
    pub from_nodes: Option<Vec<CiliumNetworkPolicyIngressDenyFromNodes>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fromRequires")]
    pub from_requires: Option<Vec<CiliumNetworkPolicyIngressDenyFromRequires>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub icmps: Option<Vec<CiliumNetworkPolicyIngressDenyIcmps>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toPorts")]
    pub to_ports: Option<Vec<CiliumNetworkPolicyIngressDenyToPorts>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyIngressDenyFromCidrSet {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cidr: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cidrGroupRef")]
    pub cidr_group_ref: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub except: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyIngressDenyFromEndpoints {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CiliumNetworkPolicyIngressDenyFromEndpointsMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyIngressDenyFromEndpointsMatchExpressions {
    pub key: String,
    pub operator: CiliumNetworkPolicyIngressDenyFromEndpointsMatchExpressionsOperator,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum CiliumNetworkPolicyIngressDenyFromEndpointsMatchExpressionsOperator {
    In,
    NotIn,
    Exists,
    DoesNotExist,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyIngressDenyFromGroups {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub aws: Option<CiliumNetworkPolicyIngressDenyFromGroupsAws>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyIngressDenyFromGroupsAws {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub region: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityGroupsIds")]
    pub security_groups_ids: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityGroupsNames")]
    pub security_groups_names: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyIngressDenyFromNodes {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CiliumNetworkPolicyIngressDenyFromNodesMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyIngressDenyFromNodesMatchExpressions {
    pub key: String,
    pub operator: CiliumNetworkPolicyIngressDenyFromNodesMatchExpressionsOperator,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum CiliumNetworkPolicyIngressDenyFromNodesMatchExpressionsOperator {
    In,
    NotIn,
    Exists,
    DoesNotExist,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyIngressDenyFromRequires {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CiliumNetworkPolicyIngressDenyFromRequiresMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyIngressDenyFromRequiresMatchExpressions {
    pub key: String,
    pub operator: CiliumNetworkPolicyIngressDenyFromRequiresMatchExpressionsOperator,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum CiliumNetworkPolicyIngressDenyFromRequiresMatchExpressionsOperator {
    In,
    NotIn,
    Exists,
    DoesNotExist,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyIngressDenyIcmps {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fields: Option<Vec<CiliumNetworkPolicyIngressDenyIcmpsFields>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyIngressDenyIcmpsFields {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub family: Option<CiliumNetworkPolicyIngressDenyIcmpsFieldsFamily>,
    #[serde(rename = "type")]
    pub r#type: IntOrString,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum CiliumNetworkPolicyIngressDenyIcmpsFieldsFamily {
    IPv4,
    IPv6,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyIngressDenyToPorts {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ports: Option<Vec<CiliumNetworkPolicyIngressDenyToPortsPorts>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyIngressDenyToPortsPorts {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endPort")]
    pub end_port: Option<i32>,
    pub port: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub protocol: Option<CiliumNetworkPolicyIngressDenyToPortsPortsProtocol>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum CiliumNetworkPolicyIngressDenyToPortsPortsProtocol {
    #[serde(rename = "TCP")]
    Tcp,
    #[serde(rename = "UDP")]
    Udp,
    #[serde(rename = "SCTP")]
    Sctp,
    #[serde(rename = "ANY")]
    Any,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyLabels {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub source: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyNodeSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CiliumNetworkPolicyNodeSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyNodeSelectorMatchExpressions {
    pub key: String,
    pub operator: CiliumNetworkPolicyNodeSelectorMatchExpressionsOperator,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum CiliumNetworkPolicyNodeSelectorMatchExpressionsOperator {
    In,
    NotIn,
    Exists,
    DoesNotExist,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicys {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub egress: Option<Vec<CiliumNetworkPolicysEgress>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "egressDeny")]
    pub egress_deny: Option<Vec<CiliumNetworkPolicysEgressDeny>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableDefaultDeny")]
    pub enable_default_deny: Option<CiliumNetworkPolicysEnableDefaultDeny>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endpointSelector")]
    pub endpoint_selector: Option<CiliumNetworkPolicysEndpointSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ingress: Option<Vec<CiliumNetworkPolicysIngress>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ingressDeny")]
    pub ingress_deny: Option<Vec<CiliumNetworkPolicysIngressDeny>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<Vec<CiliumNetworkPolicysLabels>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeSelector")]
    pub node_selector: Option<CiliumNetworkPolicysNodeSelector>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysEgress {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authentication: Option<CiliumNetworkPolicysEgressAuthentication>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub icmps: Option<Vec<CiliumNetworkPolicysEgressIcmps>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toCIDR")]
    pub to_cidr: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toCIDRSet")]
    pub to_cidr_set: Option<Vec<CiliumNetworkPolicysEgressToCidrSet>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toEndpoints")]
    pub to_endpoints: Option<Vec<CiliumNetworkPolicysEgressToEndpoints>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toEntities")]
    pub to_entities: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toFQDNs")]
    pub to_fqd_ns: Option<Vec<CiliumNetworkPolicysEgressToFqdNs>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toGroups")]
    pub to_groups: Option<Vec<CiliumNetworkPolicysEgressToGroups>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toNodes")]
    pub to_nodes: Option<Vec<CiliumNetworkPolicysEgressToNodes>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toPorts")]
    pub to_ports: Option<Vec<CiliumNetworkPolicysEgressToPorts>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toRequires")]
    pub to_requires: Option<Vec<CiliumNetworkPolicysEgressToRequires>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toServices")]
    pub to_services: Option<Vec<CiliumNetworkPolicysEgressToServices>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysEgressAuthentication {
    pub mode: CiliumNetworkPolicysEgressAuthenticationMode,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum CiliumNetworkPolicysEgressAuthenticationMode {
    #[serde(rename = "disabled")]
    Disabled,
    #[serde(rename = "required")]
    Required,
    #[serde(rename = "test-always-fail")]
    TestAlwaysFail,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysEgressIcmps {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fields: Option<Vec<CiliumNetworkPolicysEgressIcmpsFields>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysEgressIcmpsFields {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub family: Option<CiliumNetworkPolicysEgressIcmpsFieldsFamily>,
    #[serde(rename = "type")]
    pub r#type: IntOrString,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum CiliumNetworkPolicysEgressIcmpsFieldsFamily {
    IPv4,
    IPv6,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysEgressToCidrSet {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cidr: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cidrGroupRef")]
    pub cidr_group_ref: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub except: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysEgressToEndpoints {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CiliumNetworkPolicysEgressToEndpointsMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysEgressToEndpointsMatchExpressions {
    pub key: String,
    pub operator: CiliumNetworkPolicysEgressToEndpointsMatchExpressionsOperator,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum CiliumNetworkPolicysEgressToEndpointsMatchExpressionsOperator {
    In,
    NotIn,
    Exists,
    DoesNotExist,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysEgressToFqdNs {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchName")]
    pub match_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchPattern")]
    pub match_pattern: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysEgressToGroups {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub aws: Option<CiliumNetworkPolicysEgressToGroupsAws>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysEgressToGroupsAws {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub region: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityGroupsIds")]
    pub security_groups_ids: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityGroupsNames")]
    pub security_groups_names: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysEgressToNodes {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CiliumNetworkPolicysEgressToNodesMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysEgressToNodesMatchExpressions {
    pub key: String,
    pub operator: CiliumNetworkPolicysEgressToNodesMatchExpressionsOperator,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum CiliumNetworkPolicysEgressToNodesMatchExpressionsOperator {
    In,
    NotIn,
    Exists,
    DoesNotExist,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysEgressToPorts {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub listener: Option<CiliumNetworkPolicysEgressToPortsListener>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "originatingTLS")]
    pub originating_tls: Option<CiliumNetworkPolicysEgressToPortsOriginatingTls>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ports: Option<Vec<CiliumNetworkPolicysEgressToPortsPorts>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rules: Option<CiliumNetworkPolicysEgressToPortsRules>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverNames")]
    pub server_names: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminatingTLS")]
    pub terminating_tls: Option<CiliumNetworkPolicysEgressToPortsTerminatingTls>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysEgressToPortsListener {
    #[serde(rename = "envoyConfig")]
    pub envoy_config: CiliumNetworkPolicysEgressToPortsListenerEnvoyConfig,
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub priority: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysEgressToPortsListenerEnvoyConfig {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kind: Option<CiliumNetworkPolicysEgressToPortsListenerEnvoyConfigKind>,
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum CiliumNetworkPolicysEgressToPortsListenerEnvoyConfigKind {
    CiliumEnvoyConfig,
    CiliumClusterwideEnvoyConfig,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysEgressToPortsOriginatingTls {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub certificate: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateKey")]
    pub private_key: Option<String>,
    pub secret: CiliumNetworkPolicysEgressToPortsOriginatingTlsSecret,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "trustedCA")]
    pub trusted_ca: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysEgressToPortsOriginatingTlsSecret {
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysEgressToPortsPorts {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endPort")]
    pub end_port: Option<i32>,
    pub port: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub protocol: Option<CiliumNetworkPolicysEgressToPortsPortsProtocol>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum CiliumNetworkPolicysEgressToPortsPortsProtocol {
    #[serde(rename = "TCP")]
    Tcp,
    #[serde(rename = "UDP")]
    Udp,
    #[serde(rename = "SCTP")]
    Sctp,
    #[serde(rename = "ANY")]
    Any,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysEgressToPortsRules {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dns: Option<Vec<CiliumNetworkPolicysEgressToPortsRulesDns>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub http: Option<Vec<CiliumNetworkPolicysEgressToPortsRulesHttp>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kafka: Option<Vec<CiliumNetworkPolicysEgressToPortsRulesKafka>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub l7: Option<Vec<BTreeMap<String, String>>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub l7proto: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysEgressToPortsRulesDns {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchName")]
    pub match_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchPattern")]
    pub match_pattern: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysEgressToPortsRulesHttp {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerMatches")]
    pub header_matches: Option<Vec<CiliumNetworkPolicysEgressToPortsRulesHttpHeaderMatches>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysEgressToPortsRulesHttpHeaderMatches {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mismatch: Option<CiliumNetworkPolicysEgressToPortsRulesHttpHeaderMatchesMismatch>,
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<CiliumNetworkPolicysEgressToPortsRulesHttpHeaderMatchesSecret>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum CiliumNetworkPolicysEgressToPortsRulesHttpHeaderMatchesMismatch {
    #[serde(rename = "LOG")]
    Log,
    #[serde(rename = "ADD")]
    Add,
    #[serde(rename = "DELETE")]
    Delete,
    #[serde(rename = "REPLACE")]
    Replace,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysEgressToPortsRulesHttpHeaderMatchesSecret {
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysEgressToPortsRulesKafka {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiKey")]
    pub api_key: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientID")]
    pub client_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub role: Option<CiliumNetworkPolicysEgressToPortsRulesKafkaRole>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub topic: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum CiliumNetworkPolicysEgressToPortsRulesKafkaRole {
    #[serde(rename = "produce")]
    Produce,
    #[serde(rename = "consume")]
    Consume,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysEgressToPortsTerminatingTls {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub certificate: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateKey")]
    pub private_key: Option<String>,
    pub secret: CiliumNetworkPolicysEgressToPortsTerminatingTlsSecret,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "trustedCA")]
    pub trusted_ca: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysEgressToPortsTerminatingTlsSecret {
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysEgressToRequires {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CiliumNetworkPolicysEgressToRequiresMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysEgressToRequiresMatchExpressions {
    pub key: String,
    pub operator: CiliumNetworkPolicysEgressToRequiresMatchExpressionsOperator,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum CiliumNetworkPolicysEgressToRequiresMatchExpressionsOperator {
    In,
    NotIn,
    Exists,
    DoesNotExist,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysEgressToServices {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "k8sService")]
    pub k8s_service: Option<CiliumNetworkPolicysEgressToServicesK8sService>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "k8sServiceSelector")]
    pub k8s_service_selector: Option<CiliumNetworkPolicysEgressToServicesK8sServiceSelector>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysEgressToServicesK8sService {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceName")]
    pub service_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysEgressToServicesK8sServiceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    pub selector: CiliumNetworkPolicysEgressToServicesK8sServiceSelectorSelector,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysEgressToServicesK8sServiceSelectorSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CiliumNetworkPolicysEgressToServicesK8sServiceSelectorSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysEgressToServicesK8sServiceSelectorSelectorMatchExpressions {
    pub key: String,
    pub operator: CiliumNetworkPolicysEgressToServicesK8sServiceSelectorSelectorMatchExpressionsOperator,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum CiliumNetworkPolicysEgressToServicesK8sServiceSelectorSelectorMatchExpressionsOperator {
    In,
    NotIn,
    Exists,
    DoesNotExist,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysEgressDeny {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub icmps: Option<Vec<CiliumNetworkPolicysEgressDenyIcmps>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toCIDR")]
    pub to_cidr: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toCIDRSet")]
    pub to_cidr_set: Option<Vec<CiliumNetworkPolicysEgressDenyToCidrSet>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toEndpoints")]
    pub to_endpoints: Option<Vec<CiliumNetworkPolicysEgressDenyToEndpoints>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toEntities")]
    pub to_entities: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toGroups")]
    pub to_groups: Option<Vec<CiliumNetworkPolicysEgressDenyToGroups>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toNodes")]
    pub to_nodes: Option<Vec<CiliumNetworkPolicysEgressDenyToNodes>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toPorts")]
    pub to_ports: Option<Vec<CiliumNetworkPolicysEgressDenyToPorts>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toRequires")]
    pub to_requires: Option<Vec<CiliumNetworkPolicysEgressDenyToRequires>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toServices")]
    pub to_services: Option<Vec<CiliumNetworkPolicysEgressDenyToServices>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysEgressDenyIcmps {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fields: Option<Vec<CiliumNetworkPolicysEgressDenyIcmpsFields>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysEgressDenyIcmpsFields {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub family: Option<CiliumNetworkPolicysEgressDenyIcmpsFieldsFamily>,
    #[serde(rename = "type")]
    pub r#type: IntOrString,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum CiliumNetworkPolicysEgressDenyIcmpsFieldsFamily {
    IPv4,
    IPv6,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysEgressDenyToCidrSet {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cidr: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cidrGroupRef")]
    pub cidr_group_ref: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub except: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysEgressDenyToEndpoints {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CiliumNetworkPolicysEgressDenyToEndpointsMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysEgressDenyToEndpointsMatchExpressions {
    pub key: String,
    pub operator: CiliumNetworkPolicysEgressDenyToEndpointsMatchExpressionsOperator,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum CiliumNetworkPolicysEgressDenyToEndpointsMatchExpressionsOperator {
    In,
    NotIn,
    Exists,
    DoesNotExist,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysEgressDenyToGroups {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub aws: Option<CiliumNetworkPolicysEgressDenyToGroupsAws>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysEgressDenyToGroupsAws {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub region: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityGroupsIds")]
    pub security_groups_ids: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityGroupsNames")]
    pub security_groups_names: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysEgressDenyToNodes {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CiliumNetworkPolicysEgressDenyToNodesMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysEgressDenyToNodesMatchExpressions {
    pub key: String,
    pub operator: CiliumNetworkPolicysEgressDenyToNodesMatchExpressionsOperator,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum CiliumNetworkPolicysEgressDenyToNodesMatchExpressionsOperator {
    In,
    NotIn,
    Exists,
    DoesNotExist,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysEgressDenyToPorts {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ports: Option<Vec<CiliumNetworkPolicysEgressDenyToPortsPorts>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysEgressDenyToPortsPorts {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endPort")]
    pub end_port: Option<i32>,
    pub port: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub protocol: Option<CiliumNetworkPolicysEgressDenyToPortsPortsProtocol>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum CiliumNetworkPolicysEgressDenyToPortsPortsProtocol {
    #[serde(rename = "TCP")]
    Tcp,
    #[serde(rename = "UDP")]
    Udp,
    #[serde(rename = "SCTP")]
    Sctp,
    #[serde(rename = "ANY")]
    Any,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysEgressDenyToRequires {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CiliumNetworkPolicysEgressDenyToRequiresMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysEgressDenyToRequiresMatchExpressions {
    pub key: String,
    pub operator: CiliumNetworkPolicysEgressDenyToRequiresMatchExpressionsOperator,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum CiliumNetworkPolicysEgressDenyToRequiresMatchExpressionsOperator {
    In,
    NotIn,
    Exists,
    DoesNotExist,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysEgressDenyToServices {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "k8sService")]
    pub k8s_service: Option<CiliumNetworkPolicysEgressDenyToServicesK8sService>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "k8sServiceSelector")]
    pub k8s_service_selector: Option<CiliumNetworkPolicysEgressDenyToServicesK8sServiceSelector>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysEgressDenyToServicesK8sService {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceName")]
    pub service_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysEgressDenyToServicesK8sServiceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    pub selector: CiliumNetworkPolicysEgressDenyToServicesK8sServiceSelectorSelector,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysEgressDenyToServicesK8sServiceSelectorSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CiliumNetworkPolicysEgressDenyToServicesK8sServiceSelectorSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysEgressDenyToServicesK8sServiceSelectorSelectorMatchExpressions {
    pub key: String,
    pub operator: CiliumNetworkPolicysEgressDenyToServicesK8sServiceSelectorSelectorMatchExpressionsOperator,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum CiliumNetworkPolicysEgressDenyToServicesK8sServiceSelectorSelectorMatchExpressionsOperator {
    In,
    NotIn,
    Exists,
    DoesNotExist,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysEnableDefaultDeny {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub egress: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ingress: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysEndpointSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CiliumNetworkPolicysEndpointSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysEndpointSelectorMatchExpressions {
    pub key: String,
    pub operator: CiliumNetworkPolicysEndpointSelectorMatchExpressionsOperator,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum CiliumNetworkPolicysEndpointSelectorMatchExpressionsOperator {
    In,
    NotIn,
    Exists,
    DoesNotExist,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysIngress {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authentication: Option<CiliumNetworkPolicysIngressAuthentication>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fromCIDR")]
    pub from_cidr: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fromCIDRSet")]
    pub from_cidr_set: Option<Vec<CiliumNetworkPolicysIngressFromCidrSet>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fromEndpoints")]
    pub from_endpoints: Option<Vec<CiliumNetworkPolicysIngressFromEndpoints>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fromEntities")]
    pub from_entities: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fromGroups")]
    pub from_groups: Option<Vec<CiliumNetworkPolicysIngressFromGroups>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fromNodes")]
    pub from_nodes: Option<Vec<CiliumNetworkPolicysIngressFromNodes>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fromRequires")]
    pub from_requires: Option<Vec<CiliumNetworkPolicysIngressFromRequires>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub icmps: Option<Vec<CiliumNetworkPolicysIngressIcmps>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toPorts")]
    pub to_ports: Option<Vec<CiliumNetworkPolicysIngressToPorts>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysIngressAuthentication {
    pub mode: CiliumNetworkPolicysIngressAuthenticationMode,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum CiliumNetworkPolicysIngressAuthenticationMode {
    #[serde(rename = "disabled")]
    Disabled,
    #[serde(rename = "required")]
    Required,
    #[serde(rename = "test-always-fail")]
    TestAlwaysFail,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysIngressFromCidrSet {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cidr: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cidrGroupRef")]
    pub cidr_group_ref: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub except: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysIngressFromEndpoints {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CiliumNetworkPolicysIngressFromEndpointsMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysIngressFromEndpointsMatchExpressions {
    pub key: String,
    pub operator: CiliumNetworkPolicysIngressFromEndpointsMatchExpressionsOperator,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum CiliumNetworkPolicysIngressFromEndpointsMatchExpressionsOperator {
    In,
    NotIn,
    Exists,
    DoesNotExist,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysIngressFromGroups {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub aws: Option<CiliumNetworkPolicysIngressFromGroupsAws>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysIngressFromGroupsAws {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub region: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityGroupsIds")]
    pub security_groups_ids: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityGroupsNames")]
    pub security_groups_names: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysIngressFromNodes {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CiliumNetworkPolicysIngressFromNodesMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysIngressFromNodesMatchExpressions {
    pub key: String,
    pub operator: CiliumNetworkPolicysIngressFromNodesMatchExpressionsOperator,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum CiliumNetworkPolicysIngressFromNodesMatchExpressionsOperator {
    In,
    NotIn,
    Exists,
    DoesNotExist,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysIngressFromRequires {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CiliumNetworkPolicysIngressFromRequiresMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysIngressFromRequiresMatchExpressions {
    pub key: String,
    pub operator: CiliumNetworkPolicysIngressFromRequiresMatchExpressionsOperator,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum CiliumNetworkPolicysIngressFromRequiresMatchExpressionsOperator {
    In,
    NotIn,
    Exists,
    DoesNotExist,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysIngressIcmps {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fields: Option<Vec<CiliumNetworkPolicysIngressIcmpsFields>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysIngressIcmpsFields {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub family: Option<CiliumNetworkPolicysIngressIcmpsFieldsFamily>,
    #[serde(rename = "type")]
    pub r#type: IntOrString,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum CiliumNetworkPolicysIngressIcmpsFieldsFamily {
    IPv4,
    IPv6,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysIngressToPorts {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub listener: Option<CiliumNetworkPolicysIngressToPortsListener>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "originatingTLS")]
    pub originating_tls: Option<CiliumNetworkPolicysIngressToPortsOriginatingTls>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ports: Option<Vec<CiliumNetworkPolicysIngressToPortsPorts>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rules: Option<CiliumNetworkPolicysIngressToPortsRules>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverNames")]
    pub server_names: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "terminatingTLS")]
    pub terminating_tls: Option<CiliumNetworkPolicysIngressToPortsTerminatingTls>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysIngressToPortsListener {
    #[serde(rename = "envoyConfig")]
    pub envoy_config: CiliumNetworkPolicysIngressToPortsListenerEnvoyConfig,
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub priority: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysIngressToPortsListenerEnvoyConfig {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kind: Option<CiliumNetworkPolicysIngressToPortsListenerEnvoyConfigKind>,
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum CiliumNetworkPolicysIngressToPortsListenerEnvoyConfigKind {
    CiliumEnvoyConfig,
    CiliumClusterwideEnvoyConfig,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysIngressToPortsOriginatingTls {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub certificate: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateKey")]
    pub private_key: Option<String>,
    pub secret: CiliumNetworkPolicysIngressToPortsOriginatingTlsSecret,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "trustedCA")]
    pub trusted_ca: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysIngressToPortsOriginatingTlsSecret {
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysIngressToPortsPorts {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endPort")]
    pub end_port: Option<i32>,
    pub port: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub protocol: Option<CiliumNetworkPolicysIngressToPortsPortsProtocol>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum CiliumNetworkPolicysIngressToPortsPortsProtocol {
    #[serde(rename = "TCP")]
    Tcp,
    #[serde(rename = "UDP")]
    Udp,
    #[serde(rename = "SCTP")]
    Sctp,
    #[serde(rename = "ANY")]
    Any,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysIngressToPortsRules {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dns: Option<Vec<CiliumNetworkPolicysIngressToPortsRulesDns>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub http: Option<Vec<CiliumNetworkPolicysIngressToPortsRulesHttp>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kafka: Option<Vec<CiliumNetworkPolicysIngressToPortsRulesKafka>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub l7: Option<Vec<BTreeMap<String, String>>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub l7proto: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysIngressToPortsRulesDns {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchName")]
    pub match_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchPattern")]
    pub match_pattern: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysIngressToPortsRulesHttp {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "headerMatches")]
    pub header_matches: Option<Vec<CiliumNetworkPolicysIngressToPortsRulesHttpHeaderMatches>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub headers: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysIngressToPortsRulesHttpHeaderMatches {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mismatch: Option<CiliumNetworkPolicysIngressToPortsRulesHttpHeaderMatchesMismatch>,
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<CiliumNetworkPolicysIngressToPortsRulesHttpHeaderMatchesSecret>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum CiliumNetworkPolicysIngressToPortsRulesHttpHeaderMatchesMismatch {
    #[serde(rename = "LOG")]
    Log,
    #[serde(rename = "ADD")]
    Add,
    #[serde(rename = "DELETE")]
    Delete,
    #[serde(rename = "REPLACE")]
    Replace,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysIngressToPortsRulesHttpHeaderMatchesSecret {
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysIngressToPortsRulesKafka {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiKey")]
    pub api_key: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clientID")]
    pub client_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub role: Option<CiliumNetworkPolicysIngressToPortsRulesKafkaRole>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub topic: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum CiliumNetworkPolicysIngressToPortsRulesKafkaRole {
    #[serde(rename = "produce")]
    Produce,
    #[serde(rename = "consume")]
    Consume,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysIngressToPortsTerminatingTls {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub certificate: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateKey")]
    pub private_key: Option<String>,
    pub secret: CiliumNetworkPolicysIngressToPortsTerminatingTlsSecret,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "trustedCA")]
    pub trusted_ca: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysIngressToPortsTerminatingTlsSecret {
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysIngressDeny {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fromCIDR")]
    pub from_cidr: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fromCIDRSet")]
    pub from_cidr_set: Option<Vec<CiliumNetworkPolicysIngressDenyFromCidrSet>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fromEndpoints")]
    pub from_endpoints: Option<Vec<CiliumNetworkPolicysIngressDenyFromEndpoints>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fromEntities")]
    pub from_entities: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fromGroups")]
    pub from_groups: Option<Vec<CiliumNetworkPolicysIngressDenyFromGroups>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fromNodes")]
    pub from_nodes: Option<Vec<CiliumNetworkPolicysIngressDenyFromNodes>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fromRequires")]
    pub from_requires: Option<Vec<CiliumNetworkPolicysIngressDenyFromRequires>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub icmps: Option<Vec<CiliumNetworkPolicysIngressDenyIcmps>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "toPorts")]
    pub to_ports: Option<Vec<CiliumNetworkPolicysIngressDenyToPorts>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysIngressDenyFromCidrSet {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cidr: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "cidrGroupRef")]
    pub cidr_group_ref: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub except: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysIngressDenyFromEndpoints {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CiliumNetworkPolicysIngressDenyFromEndpointsMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysIngressDenyFromEndpointsMatchExpressions {
    pub key: String,
    pub operator: CiliumNetworkPolicysIngressDenyFromEndpointsMatchExpressionsOperator,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum CiliumNetworkPolicysIngressDenyFromEndpointsMatchExpressionsOperator {
    In,
    NotIn,
    Exists,
    DoesNotExist,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysIngressDenyFromGroups {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub aws: Option<CiliumNetworkPolicysIngressDenyFromGroupsAws>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysIngressDenyFromGroupsAws {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub region: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityGroupsIds")]
    pub security_groups_ids: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "securityGroupsNames")]
    pub security_groups_names: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysIngressDenyFromNodes {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CiliumNetworkPolicysIngressDenyFromNodesMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysIngressDenyFromNodesMatchExpressions {
    pub key: String,
    pub operator: CiliumNetworkPolicysIngressDenyFromNodesMatchExpressionsOperator,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum CiliumNetworkPolicysIngressDenyFromNodesMatchExpressionsOperator {
    In,
    NotIn,
    Exists,
    DoesNotExist,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysIngressDenyFromRequires {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CiliumNetworkPolicysIngressDenyFromRequiresMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysIngressDenyFromRequiresMatchExpressions {
    pub key: String,
    pub operator: CiliumNetworkPolicysIngressDenyFromRequiresMatchExpressionsOperator,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum CiliumNetworkPolicysIngressDenyFromRequiresMatchExpressionsOperator {
    In,
    NotIn,
    Exists,
    DoesNotExist,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysIngressDenyIcmps {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fields: Option<Vec<CiliumNetworkPolicysIngressDenyIcmpsFields>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysIngressDenyIcmpsFields {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub family: Option<CiliumNetworkPolicysIngressDenyIcmpsFieldsFamily>,
    #[serde(rename = "type")]
    pub r#type: IntOrString,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum CiliumNetworkPolicysIngressDenyIcmpsFieldsFamily {
    IPv4,
    IPv6,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysIngressDenyToPorts {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ports: Option<Vec<CiliumNetworkPolicysIngressDenyToPortsPorts>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysIngressDenyToPortsPorts {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endPort")]
    pub end_port: Option<i32>,
    pub port: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub protocol: Option<CiliumNetworkPolicysIngressDenyToPortsPortsProtocol>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum CiliumNetworkPolicysIngressDenyToPortsPortsProtocol {
    #[serde(rename = "TCP")]
    Tcp,
    #[serde(rename = "UDP")]
    Udp,
    #[serde(rename = "SCTP")]
    Sctp,
    #[serde(rename = "ANY")]
    Any,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysLabels {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub source: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysNodeSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<CiliumNetworkPolicysNodeSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicysNodeSelectorMatchExpressions {
    pub key: String,
    pub operator: CiliumNetworkPolicysNodeSelectorMatchExpressionsOperator,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum CiliumNetworkPolicysNodeSelectorMatchExpressionsOperator {
    In,
    NotIn,
    Exists,
    DoesNotExist,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyStatus {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "derivativePolicies")]
    pub derivative_policies: Option<BTreeMap<String, CiliumNetworkPolicyStatusDerivativePolicies>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CiliumNetworkPolicyStatusDerivativePolicies {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enforcing: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lastUpdated")]
    pub last_updated: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localPolicyRevision")]
    pub local_policy_revision: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ok: Option<bool>,
}

